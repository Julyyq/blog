<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>JavaScript循环中的引用</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="/stylesheets/custom.css">
    <meta name="viewport" content="target-densitydpi=320,width=480,user-scalable=no">
    <meta content="True" name="HandheldFriendly">
    <meta content="480" name="MobileOptimized">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <section>
        <h1 id="javascript">JavaScript循环中的引用</h1>

<p>假如有如下一段html：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;ul&gt;
  &lt;li&gt;&lt;a href=""&gt;item1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;item2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;item3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;item4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;item5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</div>

<p>现在我们需要给每一个li里面的绑定一个click事件，根据它的位置(1,2,3…)来进行一些操作,最直接的办法可能会想到这样做：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var a = document.getElementsByTagName("a");

a[0].onclick = function() {
  console.log(0);
}
a[1].onclick = function() {
  console.log(1);
}
a[2].onclick = function() {
  console.log(2);
}
a[3].onclick = function() {
  console.log(3);
}
a[4].onclick = function() {
  console.log(4);
}
</code></pre>
</div>

<p>这样做感觉比较蠢是吧？然后想到这不是非常符合用for循环吗？OK，我们来试试。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var a = document.getElementsByTagName("a"),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = function() {
    console.log(i);
  }
}
</code></pre>
</div>

<p>在浏览器中的测试结果如下：</p>

<p><img src="/images/js_s_1.jpg" alt="" /></p>

<p>竟然无论点哪个都会输出5！究竟是哪里错了？</p>

<p>我们来理一理思路。首先我们获取到了所有的a元素，将它保存在a数组里面，然后对a进行循环，当其为i的时候，给第i个a元素绑定click事件，并输出i。恩，这样分析下来，整个过程好像也没什么错误。然后让我们来想想当点击某个a元素的时候，计算机是如何运行这个程序的。比如我点了第3个a元素，此时，计算机执行<code class="highlighter-rouge">console.log(i)</code>，然而这里的i出问题了，因为不论点击哪个a元素，i都是5，这是为什么呢？可能你到这里已经看出来点端倪了，我们犯了个很基础的错误，这个错误就是：</p>

<blockquote>
  <p>我们给每个a绑定click事件的时候，只是保存了<code class="highlighter-rouge">console.log(i)</code>这个执行语句，而没有保存i，只是对i进行了引用，只有当click事件触发，程序需要输出i的时候，计算机才会找i到底等于多少，此时，for循环已经执行完毕，所以i等于5。</p>
</blockquote>

<p>知道了原因，那么该如何解决呢？主要有两种办法，原理都是每次循环的时候，对i进行copy，把i的值存在一个不会被循环改变的变量里面。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>方法1：
var a = document.getElementsByTagName("a"),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = (function(n) {
    return function() {
      console.log(n+1);
    }
  })(i);
}

方法2：
var a = document.getElementsByTagName("a"),i;

for(i=0;i&lt;a.length;i++) {
  (function(n) {
    a[n].onclick = function() {
      console.log(n+1);
    }
  })(i);
}
</code></pre>
</div>

<p>两个方法的相同之处是，通过一个匿名函数传递i变量，然后在其内部创建备份。
不同之处是，方法1在匿名函数内部又返回了一个函数，这种方式会将一些“变量或者操作”隐藏在内部，不被外部所访问到，在自己开发组件的时候，非常有帮助。</p>

<p>OK，似乎这个问题已经解释清楚了，可是我还想再多讨论一个问题。面对这种需求，往往我们会用jQuery来处理，因为jQuery用的人实在是太多了，即便像百度这样的公司，虽然有自己的JS开发库，但一些部门还是直接使用jQuery，毕竟它真的很好用。来看jQuery如何处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$("a").each(function(i,el) {
  $(this).click(function() {
    console.log(i+1); 
  });
});
</code></pre>
</div>

<p>当然用jQuery处理这种问题，不止这一种写法，以上只是一个比较中规中矩的写法。
可以看到，使用jQuery，这样的坑已经不存在了，因为jQuery已经替我们填好了坑，那么jQuery是怎么处理的呢？以下是<a href="http://code.jquery.com/jquery-1.10.1.js">jQuery1.10.1</a>中each方法的核心代码：</p>

<p><img src="/images/jquery_each.jpg" alt="" /></p>

<p>我们只需要看这一段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for ( ; i &lt; length; i++ ) {
  value = callback.call( obj[ i ], i, obj[ i ] );

  if ( value === false ) {
    break;
  }
}
</code></pre>
</div>

<p>看到这句<code class="highlighter-rouge">callback.call( obj[ i ], i, obj[ i ] )</code>，于是也可以将上面的方法稍微改动一下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var a = document.getElementsByTagName("a"),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = (function(n) {
    return function() {
      console.log(n+1);  
    }
  }).call(this,i);
}
</code></pre>
</div>

<p>可以看到与方法1和2大同小异，多了个call方法传递参数而已，同样也可以改为apply方法，但核心原理都是一样的：即为在每一次循环的时候，备份i。</p>

<p>全文完</p>

      </section>
      <dl class="new-cat">
        <dt>文章列表</dt>
        <dd><a href="/2013/09/30/stylus_6.html">stylus教程6</a></dd>
        <dd><a href="/2013/09/30/stylus_5.html">stylus教程5</a></dd>
        <dd><a href="/2013/09/29/stylus_4.html">stylus教程4</a></dd>
        <dd><a href="/2013/09/29/stylus_3.html">stylus教程3</a></dd>
        <dd><a href="/2013/09/25/palindrome.html">判断是否回文数的Javascript实现</a></dd>
        <dd><a href="/2013/09/25/javascript_array_unique.html">使用JavaScript对数组去重</a></dd>
        <dd><a href="/2013/09/25/secret_of_JavaScript_2.html">JavaScript循环中的引用2</a></dd>
        <dd><a href="/2013/08/30/stylus_2.html">stylus教程2</a></dd>
        <dd><a href="/2013/08/29/stylus_1.html">stylus教程1</a></dd>
        <dd><a href="/2012/10/20/js_example.html">快速实现轮播效果</a></dd>
        <dd><a href="/2012/10/01/html_doctype.html">HTML文档的标准模式和怪异模式</a></dd>
        <dd><a href="/2012/09/03/http_header.html">Http Header简单介绍</a></dd>
        <dd><a href="/2012/09/02/html_charset.html">给html设置charset属性</a></dd>
        <dd><a href="/2012/09/01/secret_of_JavaScript.html">JavaScript循环中的引用</a></dd>
        <dd><a href="/2012/08/25/use_JavaScript_operate_cookie.html">JavaScript操作cookie</a></dd>
      </dl>
    </div>
  </body>
</html>
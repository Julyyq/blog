<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>JavaScript循环中的引用</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="/stylesheets/custom.css">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>July的blog</h1>
        <p class="view">
            <a href="https://github.com/Julyyq/blog">View the Project on GitHub 
                <small>Julyyq/blog</small>
            </a>
        </p>
      </header>
      <dl class="new-cat">
        <dt>文章列表</dt>
        <dd><a href="/2012/10/20/js_example.html">快速实现轮播效果</a></dd>
        <dd><a href="/2012/10/01/html_doctype.html">HTML文档的标准模式和怪异模式</a></dd>
        <dd><a href="/2012/09/03/http_header.html">Http Header简单介绍</a></dd>
        <dd><a href="/2012/09/02/html_charset.html">给html设置charset属性</a></dd>
        <dd><a href="/2012/09/01/secret_of_JavaScript.html">JavaScript循环中的引用</a></dd>
        <dd><a href="/2012/08/25/use_JavaScript_operate_cookie.html">JavaScript操作cookie</a></dd>
      </dl>
      <section>
        <h1 id='javascript'>JavaScript循环中的引用</h1>

<p>假如有如下一段html：</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;item1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;item2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;item3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;item4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;item5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>

<p>现在我们需要给每一个li里面的绑定一个click事件，根据它的位置(1,2,3&#8230;)来进行一些操作,最直接的办法可能会想到这样做：</p>

<pre><code>var a = document.getElementsByTagName(&quot;a&quot;);

a[0].onclick = function() {
  console.log(0);
}
a[1].onclick = function() {
  console.log(1);
}
a[2].onclick = function() {
  console.log(2);
}
a[3].onclick = function() {
  console.log(3);
}
a[4].onclick = function() {
  console.log(4);
}</code></pre>

<p>这样做感觉比较蠢是吧？然后想到这不是非常符合用for循环吗？OK，我们来试试。</p>

<pre><code>var a = document.getElementsByTagName(&quot;a&quot;),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = function() {
    console.log(i);
  }
}</code></pre>

<p>在浏览器中的测试结果如下：</p>

<p><img alt='' src='/images/js_s_1.jpg' /></p>

<p>竟然无论点哪个都会输出5！究竟是哪里错了？</p>

<p>我们来理一理思路。首先我们获取到了所有的a元素，将它保存在a数组里面，然后对a进行循环，当其为i的时候，给第i个a元素绑定click事件，并输出i。恩，这样分析下来，整个过程好像也没什么错误。然后让我们来想想当点击某个a元素的时候，计算机是如何运行这个程序的。比如我点了第3个a元素，此时，计算机执行<code>console.log(i)</code>，然而这里的i出问题了，因为不论点击哪个a元素，i都是5，这是为什么呢？可能你到这里已经看出来点端倪了，我们犯了个很基础的错误，这个错误就是：</p>

<blockquote>
<p>我们给每个a绑定click事件的时候，只是保存了<code>console.log(i)</code>这个执行语句，而没有保存i，只是对i进行了引用，只有当click事件触发，程序需要输出i的时候，计算机才会找i到底等于多少，此时，for循环已经执行完毕，所以i等于5。</p>
</blockquote>

<p>知道了原因，那么该如何解决呢？主要有两种办法，原理都是每次循环的时候，对i进行copy，把i的值存在一个不会被循环改变的变量里面。</p>

<pre><code>方法1：
var a = document.getElementsByTagName(&quot;a&quot;),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = (function(n) {
    return function() {
      console.log(n+1);
    }
  })(i);
}

方法2：
var a = document.getElementsByTagName(&quot;a&quot;),i;

for(i=0;i&lt;a.length;i++) {
  (function(n) {
    a[n].onclick = function() {
      console.log(n+1);
    }
  })(i);
}</code></pre>

<p>两个方法的相同之处是，通过一个匿名函数传递i变量，然后在其内部创建备份。 不同之处是，方法1在匿名函数内部又返回了一个函数，这种方式会将一些“变量或者操作”隐藏在内部，不被外部所访问到，在自己开发组件的时候，非常有帮助。</p>

<p>OK，似乎这个问题已经解释清楚了，可是我还想再多讨论一个问题。面对这种需求，往往我们会用jQuery来处理，因为jQuery用的人实在是太多了，即便像百度这样的公司，虽然有自己的JS开发库，但一些部门还是直接使用jQuery，毕竟它真的很好用。来看jQuery如何处理：</p>

<pre><code>$(&quot;a&quot;).each(function(i,el) {
  $(this).click(function() {
    console.log(i+1); 
  });
});</code></pre>

<p>当然用jQuery处理这种问题，不止这一种写法，以上只是一个比较中规中矩的写法。 可以看到，使用jQuery，这样的坑已经不存在了，因为jQuery已经替我们填好了坑，那么jQuery是怎么处理的呢？以下是<a href='http://code.jquery.com/jquery-1.10.1.js'>jQuery1.10.1</a>中each方法的核心代码：</p>

<p><img alt='' src='/images/jquery_each.jpg' /></p>

<p>我们只需要看这一段：</p>

<pre><code>for ( ; i &lt; length; i++ ) {
  value = callback.call( obj[ i ], i, obj[ i ] );

  if ( value === false ) {
    break;
  }
}</code></pre>

<p>看到这句<code>callback.call( obj[ i ], i, obj[ i ] )</code>，于是也可以将上面的方法稍微改动一下：</p>

<pre><code>var a = document.getElementsByTagName(&quot;a&quot;),i;

for(i=0;i&lt;a.length;i++) {
  a[i].onclick = (function(n) {
    return function() {
      console.log(n+1);  
    }
  }).call(this,i);
}</code></pre>

<p>可以看到与方法1和2大同小异，多了个call方法传递参数而已，同样也可以改为apply方法，但核心原理都是一样的：即为在每一次循环的时候，备份i。</p>

<p>全文完</p>
        <!-- 友言 BEGIN -->
        <div id="uyan_frame"></div>
        <script type="text/javascript" id="UYScript" src="http://v1.uyan.cc/js/iframe.js?UYUserId=1803257" async=""></script>
        <!-- 友言 END -->
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/Julyyq">Julyyq</a></p>
        <p>
            <small>Hosted on GitHub Pages &mdash; Theme by 
                <a href="https://github.com/orderedlist">orderedlist</a>
            </small>
        </p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
  </body>
</html>